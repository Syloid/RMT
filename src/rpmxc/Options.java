/*
 * The MIT License
 *
 * Copyright 2018 RedEyedJealousy.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package rpmxc;

import java.awt.Component;
import java.awt.Font;
import java.awt.Image;
import java.awt.Window;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JEditorPane;
import javax.swing.JFileChooser;
import static javax.swing.JFrame.EXIT_ON_CLOSE;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.UIManager;
import javax.swing.event.HyperlinkEvent;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;
import mmd.MaterialMakerv2;

/**
 *
 * @author alex
 */
public class Options extends javax.swing.JFrame {

    /*Icons*/
    ImageIcon ico = new ImageIcon(Options.class.getResource("/icon/ico.png"));
    static ImageIcon img = new ImageIcon(Options.class.getResource("/icon/icosmall.png"));
    /*MaterialClass*/
    static MaterialMakerv2 v2 = new MaterialMakerv2();
    /*Parent*/
    static Component parentComponent;//menu window
    /*Pubics*/
    public static String filePath;// .x path
    public static String destination; //folder of the materials

    /*Window*/
    boolean user;
    /*Checks*/
    static boolean normalCheck;

    static boolean specularCheck;

    static boolean smoothnessCheck;

    static boolean metalnessCheck;

    static boolean parallaxCheck;

    static boolean occlusionCheck;

    /**
     * Creates new form Options
     */
    public Options() {
        initComponents();
    }

    private static void Windows() {
        try {
            for (UIManager.LookAndFeelInfo info : UIManager.getInstalledLookAndFeels()) {
                UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
                break;
            }
        } catch (Exception e) {

        }
    }

    public static boolean getNormalCheck() {
        return Options.NormalMap.isSelected();
    }

    public static boolean getSpecularCheck() {
        return Options.SpecularMap.isSelected();
    }

    public static boolean getSmoothnessCheck() {
        return Options.SmoothnessMap.isSelected();
    }

    public static boolean getMetalnessCheck() {
        return Options.MetalnessMap.isSelected();
    }

    public static boolean getParallaxCheck() {
        return Options.ParallaxMap.isSelected();
    }

    public static boolean getOcclusionCheck() {
        return Options.OcclusionMap.isSelected();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        buttonGroup2 = new javax.swing.ButtonGroup();
        buttonGroup3 = new javax.swing.ButtonGroup();
        jLabel1 = new javax.swing.JLabel();
        NormalMap = new javax.swing.JRadioButton();
        SpecularMap = new javax.swing.JRadioButton();
        SmoothnessMap = new javax.swing.JRadioButton();
        MetalnessMap = new javax.swing.JRadioButton();
        ParallaxMap = new javax.swing.JRadioButton();
        OcclusionMap = new javax.swing.JRadioButton();
        Submit = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Select Maps to Add");
        setIconImage(getIconImage());
        setResizable(false);
        setType(java.awt.Window.Type.POPUP);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                formWindowClosed(evt);
            }
        });

        jLabel1.setText("Select which kind of Map you would like to add to the Material Files...");

        NormalMap.setText("NORMAL_MAP_FILE");
        NormalMap.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NormalMapActionPerformed(evt);
            }
        });

        SpecularMap.setText("SPECULAR_MAP_FILE");

        SmoothnessMap.setText("SMOOTHNESS_MAP_FILE");

        MetalnessMap.setText("METALNESS_MAP_FILE");

        ParallaxMap.setText("PARALLAX_MAP_FILE");

        OcclusionMap.setText("OCCLUSION_MAP_FILE");

        Submit.setText("Submit");
        Submit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SubmitActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(295, 295, 295)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(OcclusionMap)
                    .addComponent(ParallaxMap)
                    .addComponent(MetalnessMap)
                    .addComponent(SmoothnessMap)
                    .addComponent(SpecularMap)
                    .addComponent(NormalMap))
                .addContainerGap())
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(213, 213, 213)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addGap(213, 213, 213))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(Submit)
                        .addGap(115, 115, 115))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(65, 65, 65)
                .addComponent(jLabel1)
                .addGap(60, 60, 60)
                .addComponent(NormalMap)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(SpecularMap)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(SmoothnessMap)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(MetalnessMap)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(ParallaxMap)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(OcclusionMap)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 75, Short.MAX_VALUE)
                .addComponent(Submit)
                .addGap(41, 41, 41))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void NormalMapActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NormalMapActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_NormalMapActionPerformed

    private void SubmitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SubmitActionPerformed
        //need to follow the code from here
        /*Initialization of every check*/
        normalCheck = getNormalCheck();

        specularCheck = getSpecularCheck();

        smoothnessCheck = getSmoothnessCheck();

        metalnessCheck = getMetalnessCheck();

        parallaxCheck = getParallaxCheck();

        occlusionCheck = getOcclusionCheck();
        if (normalCheck == false && specularCheck == false && smoothnessCheck == false && metalnessCheck == false && parallaxCheck == false && occlusionCheck == false) {
            JOptionPane.showMessageDialog(this, "<html>"
                    + "Please, select at least one option... <br><br>There's no point of using this feature if you are not going to add any maps."
                    + "</html>", "Select one Option", JOptionPane.WARNING_MESSAGE, img);

        } else {
            user = true;
            parentComponent.setVisible(true);
            this.setLocationRelativeTo(parentComponent);
            this.setVisible(false);
            int[] errors = new int[10000];//really bad approach but im noob
            for (int i = 0; i < errors.length; i++) {
                errors[i] = -1;//initializing 
            }
            String normalMapsPath = "";
            String specularMapsPath = "";
            String smoothnessMapsPath = "";
            String metalnessMapsPath = "";
            String parallaxMapsPath = "";
            String occlusionMapsPath = "";

            //HACER ARRAY DE STRINGS PARA SUFFIX Y FILENAME
            //***************************//
            String suffixes[] = new String[6];
            //***************************//
            /*If the user selected xxxxMap we need to know where they are located */
            if (normalCheck) {
                normalMapsPath = getMapsPath(destination, parentComponent, "Normal");
                suffixes[0] = getSuffix("Normal");
            }
            if (specularCheck) {
                specularMapsPath = getMapsPath(destination, parentComponent, "Specular");
                suffixes[1] = getSuffix("Specular");
            }
            if (smoothnessCheck) {
                smoothnessMapsPath = getMapsPath(destination, parentComponent, "Smoothness");
                suffixes[2] = getSuffix("Smoothness");
            }
            if (metalnessCheck) {
                metalnessMapsPath = getMapsPath(destination, parentComponent, "Metalness");
                suffixes[3] = getSuffix("Metalness");
            }
            if (parallaxCheck) {
                parallaxMapsPath = getMapsPath(destination, parentComponent, "Parallax");
                suffixes[4] = getSuffix("Parallax");
            }
            if (occlusionCheck) {
                occlusionMapsPath = getMapsPath(destination, parentComponent, "Occlusion");
                suffixes[5] = getSuffix("Occlusion");
            }
            
            for (int i = 0; i < suffixes.length; i++) {
                
            }
            
            try {
                BufferedReader br;
                br = new BufferedReader(new FileReader(new File(filePath)));
                String line = br.readLine();
                String catchOld = "";
                int sub = 0;
                int j = 0;

                File[] RealFiles = new File[6];
                String[] relative = new String[6];
                while (line != null) {
                    if (line.contains("TextureFilename") && !line.contains("template")) {
                        line = br.readLine();//reading actual tex file
                        //******HERE COMES THE SPAGHETTI CODE*******//
                        try {
                            if (normalCheck) {
                                try {
                                    RealFiles[0] = getRealFiles(line, normalMapsPath, suffixes, 0);
                                } catch (Exception e) {
                                    relative[0] = "FileNotFound";
                                    errors[j] = sub;//saving which sub has an error
                                    j++;
                                }
                                if (RealFiles[0].toString().equalsIgnoreCase("error") || RealFiles[0].toString().equalsIgnoreCase("null")) {//ERRORS
                                    relative[0] = "FileNotFound";
                                    errors[j] = sub;//saving which sub has an error
                                    j++;
                                } else {//RELATIVIZE SUCCESSFUL FILES
                                    String destinationParent = new File(destination).toString();
                                    relative[0] = mmd.toRelative.convertToRelativePath(destinationParent, RealFiles[0].toString());//relativize path
                                }

                            }
                            if (specularCheck) {
                                try {
                                    RealFiles[1] = getRealFiles(line, specularMapsPath, suffixes, 1);
                                } catch (Exception e) {
                                    relative[1] = "FileNotFound";
                                    errors[j] = sub;//saving which sub has an error
                                    j++;
                                }
                                if (RealFiles[1].toString().equalsIgnoreCase("error") || RealFiles[1].toString().equalsIgnoreCase("null")) {//ERRORS
                                    relative[1] = "FileNotFound";
                                    errors[j] = sub;//saving which sub has an error
                                    j++;
                                } else {//RELATIVIZE SUCCESSFUL FILES
                                    String destinationParent = new File(destination).toString();
                                    relative[1] = mmd.toRelative.convertToRelativePath(destinationParent, RealFiles[1].toString());//relativize path
                                }
                                
                            }
                            if (smoothnessCheck) {
                                try {
                                    RealFiles[2] = getRealFiles(line, smoothnessMapsPath, suffixes, 2);
                                } catch (Exception e) {
                                    relative[2] = "FileNotFound";
                                    errors[j] = sub;//saving which sub has an error
                                    j++;
                                }
                                if (RealFiles[2].toString().equalsIgnoreCase("error") || RealFiles[2].toString().equalsIgnoreCase("null")) {//ERRORS
                                    relative[2] = "FileNotFound";
                                    errors[j] = sub;//saving which sub has an error
                                    j++;
                                } else {//RELATIVIZE SUCCESSFUL FILES
                                    String destinationParent = new File(destination).toString();
                                    relative[2] = mmd.toRelative.convertToRelativePath(destinationParent, RealFiles[2].toString());//relativize path
                                }

                            }
                            if (metalnessCheck) {
                                try {
                                    RealFiles[3] = getRealFiles(line, metalnessMapsPath, suffixes, 3);
                                } catch (Exception e) {
                                    relative[3] = "FileNotFound";
                                    errors[j] = sub;//saving which sub has an error
                                    j++;
                                }
                                if (RealFiles[3].toString().equalsIgnoreCase("error") || RealFiles[3].toString().equalsIgnoreCase("null")) {//ERRORS
                                    relative[3] = "FileNotFound";
                                    
                                    errors[j] = sub;//saving which sub has an error
                                    j++;
                                } else {//RELATIVIZE SUCCESSFUL FILES
                                    String destinationParent = new File(destination).toString();
                                    relative[3] = mmd.toRelative.convertToRelativePath(destinationParent, RealFiles[3].toString());//relativize path
                                }

                            }
                            if (parallaxCheck) {
                                try {
                                    RealFiles[4] = getRealFiles(line, parallaxMapsPath, suffixes, 4);
                                } catch (Exception e) {
                                    relative[4] = "FileNotFound";
                                    errors[j] = sub;//saving which sub has an error
                                    j++;
                                }
                                if (RealFiles[4].toString().equalsIgnoreCase("error") || RealFiles[4].toString().equalsIgnoreCase("null")) {//ERRORS
                                    relative[4] = "FileNotFound";
                                    errors[j] = sub;//saving which sub has an error
                                    j++;
                                } else {//RELATIVIZE SUCCESSFUL FILES
                                    String destinationParent = new File(destination).toString();
                                    relative[4] = mmd.toRelative.convertToRelativePath(destinationParent, RealFiles[4].toString());//relativize path
                                }

                            }
                            if (occlusionCheck) {
                                try {
                                    RealFiles[5] = getRealFiles(line, occlusionMapsPath, suffixes, 5);
                                } catch (Exception e) {
                                    relative[5] = "FileNotFound";
                                    errors[j] = sub;//saving which sub has an error
                                    j++;
                                }
                                if (RealFiles[5].toString().equalsIgnoreCase("error") || RealFiles[5].toString().equalsIgnoreCase("null")) {//ERRORS
                                    relative[5] = "FileNotFound";
                                    errors[j] = sub;//saving which sub has an error
                                    j++;
                                } else {//RELATIVIZE SUCCESSFUL FILES
                                    String destinationParent = new File(destination).toString();
                                    relative[5] = mmd.toRelative.convertToRelativePath(destinationParent, RealFiles[5].toString());//relativize path
                                }

                            }
                        } catch (Exception e) {
                            
                        }
                        /**
                         * ****************:)*************************
                         */
                        createMaterial(relative, destination, sub);
                        sub++;
                    }
                    line = br.readLine();
                }
                br.close();
                File file_to_delete = v2.getFileToEdit();
                file_to_delete.delete();

                attach(filePath, sub, destination, errors, parentComponent);
                end(parentComponent);
                /*fixing edit window*/
                MaterialMakerv2 foo = new MaterialMakerv2();
                foo.setRecursive(false);

            } catch (IOException e) {

            }
        }
    }//GEN-LAST:event_SubmitActionPerformed

    private void formWindowClosed(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosed
        // TODO add your handling code here:
        if (user != true) {
            java.awt.Window win[] = java.awt.Window.getWindows();
            for (Window win1 : win) {
                win1.dispose();
            }
            try {
                mmd.Main.main(null);
            } catch (Exception ex) {
                Logger.getLogger(Start.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }//GEN-LAST:event_formWindowClosed
    static Start st = new Start();

    /**
     * @param args the command line arguments
     * @param a
     */
    public static void main(String args[], Component a) throws IOException {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        Windows();
        //</editor-fold>
        parentComponent = a;
        /* Create and display the form */

        start(a);//welcome to spaghetti code

    }

    public static void initializeOptions(Component parentComponent) {
        Options op = new Options();
        java.awt.EventQueue.invokeLater(() -> {
            /*ICON*/
            Image image = null;
            try {

                image = ImageIO.read(Options.class.getResource("/icon/icosmall.png"));
            } catch (IOException ex) {
                Logger.getLogger(Options.class.getName()).log(Level.SEVERE, null, ex);
            }
            /*-----------------------------*/

            op.setLocationRelativeTo(parentComponent);
            op.setIconImage(image);
            parentComponent.setVisible(false);

            op.setVisible(true);

        });

        /*this sucks*/
        op.setAlwaysOnTop(true);
        op.setAlwaysOnTop(false);
        /*-------------------*/
    }

    public static void start(Component a) {
        a.setVisible(true);
        JFileChooser fileChooser = new JFileChooser();
        String pathFile = "../../../";
        fileChooser.setCurrentDirectory(new java.io.File(pathFile));
        FileFilter x = new FileNameExtensionFilter(".x Files", "x");
        fileChooser.setFileFilter(x);
        fileChooser.setDialogTitle("Select .x File to get the Texture's Names from");

        try {
            int selection = fileChooser.showOpenDialog(a);
            if (selection == JFileChooser.APPROVE_OPTION) {
                filePath = fileChooser.getSelectedFile().getAbsolutePath();
                JFileChooser dest;
                destination = "";

                dest = new JFileChooser();
                dest.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
                dest.setAcceptAllFileFilterUsed(false);
                dest.setDialogTitle("Specify the destination folder where the Materials will be created");
                if (dest.showOpenDialog(a) == JFileChooser.APPROVE_OPTION) {
                    destination = dest.getSelectedFile().toString();
                    //if material common doesnt exist in destiantion/materialcommon create it
                    if (!new File(destination + "/material_common_2.0.fxsub").exists()) {
                        
                        File orig = new File("../../Materials/material_common_2.0.fxsub");
                        File desti = new File(destination + "/material_common_2.0.fxsub");
                        copyFile(orig, desti);
                    } else {
                        
                    }
                    initializeOptions(parentComponent);
                } else {
                    File file_to_delete = v2.getFileToEdit();
                    file_to_delete.delete();
                }

            } else {

                File file_to_delete = v2.getFileToEdit();
                
                file_to_delete.delete();
                

                
            }

        } catch (Exception e) {

        }
    }

    public static File compareFile(String texturename, String mapsPath) {
        File[] getFiles = listFiles(mapsPath);
        File finalFile = new File(texturename);

        for (File file : getFiles) {
            String newPath = file.getName();
            newPath = newPath.substring(0, newPath.lastIndexOf("."));
            if (newPath.equals(texturename)) {
                //if the name of the texturename is the same as the one
                finalFile = file.getAbsoluteFile();
            }
        }
        if (!finalFile.exists()) {
            finalFile = new File("error");
        }
        return finalFile;
    }

    public static File[] listFiles(String path) {
        File folder = new File(path);
        File[] listOfFiles;
        listOfFiles = folder.listFiles();

        return listOfFiles;
    }

    public static String getMapsPath(String dest, Component a, String type) {
        String path;
        JFileChooser fc = new JFileChooser();
        fc.setCurrentDirectory(new File(dest));
        fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        fc.setDialogTitle("Specify the folder where your " + type + " Maps are stored");
        fc.setAcceptAllFileFilterUsed(false);
        int x;
        do {
            x = fc.showOpenDialog(a);

        } while (x != 0);

        return fc.getSelectedFile().getPath();
    }

    public static void attach(String x, int num, String matfolder, int[] errors, Component a) {

        String MikuMikuDanceProjectPath = "";
        x = new File(x).getName();
        String noExtension = "";
        for (int i = 0; i < x.length(); i++) {
            if (x.charAt(i) == '.') {
                break;//really bad approach tbh
            } else {
                noExtension += x.charAt(i);
            }

        }
        
        int input = JOptionPane.showConfirmDialog(a,//component,
                "<html>Would you like to attach all the " + num + " Materials created into your MikuMikuDance Project?</html>", "Attach Materials",
                JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.INFORMATION_MESSAGE, img);
        if (input == JOptionPane.YES_OPTION) {
            JFileChooser fileChooser = new JFileChooser();
            fileChooser.setDialogTitle("Select your MikuMikuDance Project File (.pmm)");
            FileFilter MMD = new FileNameExtensionFilter("MikuMikuDance", "pmm");
            fileChooser.setFileFilter(MMD);
            int selectpmx = fileChooser.showOpenDialog(a);
            if (selectpmx == 0) {
                MikuMikuDanceProjectPath = fileChooser.getSelectedFile().getAbsolutePath();//get pmx path
                MikuMikuDanceProjectPath = MikuMikuDanceProjectPath.replace(".pmm", ".emm");

                try {
                    BufferedReader br = new BufferedReader(new FileReader(MikuMikuDanceProjectPath));
                    String line = "";
                    String pmdNum = "";

                    line = br.readLine();

                    while (line != null) {

                        if (line.contains(noExtension)) {

                            for (int i = 0; i < line.indexOf('='); i++) {
                                pmdNum += line.charAt(i);
                            }
                            String n = pmdNum.replaceAll("[^0-9]", "");
                            pmdNum = line.substring(0, 3) + n;

                            line = null; //we are done with this loop

                        } else {
                            line = br.readLine();
                        }
                    }
                    
                    br.close();
                    //Now we read again the file for attaching them materials
                    String fors = "";
                    //generate the string
                    String err = "";
                    int nextLine = 22;
                    int count = 0;
                    for (int i = 0; i < num; i++) {//haciendo un for porque soy un fracasado y no se recursividad bien

                        if (isInErrors(i, errors) == true) {
                            if (count == nextLine) {
                                err += "\r\n";
                                count = 0;
                            }
                            /*goofy ass approach*/
                            if (i < 10) {
                                err += "  " + i + ",  ";
                            } else if (i >= 10 && i < 100) {
                                err += " " + i + ", ";
                            } else {
                                err += "" + i + ",";
                            }

                            count++;
                        } else {
                            fors += pmdNum + "[" + i + "] = " + matfolder + "/sub_" + i + ".fx" + "\r\n";
                        }
                    }
                    fors = fors.replaceAll("/", "\\\\"); //replace forward slash to backslash

                    writeEmm(br, MikuMikuDanceProjectPath, pmdNum, fors);
                    if (!err.isEmpty()) {
                        err = err.substring(0, err.lastIndexOf(","));
                        err += ".";
                        JOptionPane.showMessageDialog(parentComponent, "The application had some issues while finding some MapFiles.\n\n"
                                + "The following files hasn't been attached: \n\n"
                                + err, "Message", JOptionPane.WARNING_MESSAGE, img);
                    } else {
                        JOptionPane.showMessageDialog(parentComponent, "<html>"
                                + "All the materials has been successfully attached!"
                                + "</html>", "Message", JOptionPane.WARNING_MESSAGE, img);
                    }

                } catch (Exception e) {

                }
            }

        }
    }

    public static void end(Component p) {
        JLabel label = new JLabel();
        Font font = label.getFont();

        StringBuffer style = new StringBuffer("font-family:" + font.getFamily() + ";");
        style.append("font-weight:").append(font.isBold() ? "bold" : "normal").append(";");
        style.append("font-size:").append(font.getSize()).append("pt;");

        JEditorPane ep = new JEditorPane("text/html", "<html><body style=\"" + style + "\">" //
                + "Keep in mind that this feature is in a beta status, so if you have found any issue <a href=\"https://github.com/Syloid/RMT/issues\">open a new issue</a>" //
                + "</body></html>");

        ep.addHyperlinkListener((HyperlinkEvent e) -> {
            if (e.getEventType().equals(HyperlinkEvent.EventType.ACTIVATED)) {
                try {
                    java.awt.Desktop.getDesktop().browse(java.net.URI.create("https://github.com/Syloid/RMT/issues"));
                } catch (IOException ex) {

                }
            }
        });
        ep.setEditable(false);
        ep.setBackground(label.getBackground());
        JOptionPane.showMessageDialog(parentComponent, ep, "Message", JOptionPane.WARNING_MESSAGE, img);
    }

    public static boolean isInErrors(int i, int[] errors) {
        for (int j = 0; j < errors.length; j++) {
            if (errors[j] == i) {//if that subset has errors return true;
                return true;
            }
        }
        return false;
    }

    public static void writeEmm(BufferedReader br, String MikuMikuDanceProjectPath, String pmdNum, String fors) {
        try {
            br = new BufferedReader(new FileReader(MikuMikuDanceProjectPath));

            String line = br.readLine();
            Boolean firstOne = true;
            String oldtext = "";
            
            while (line != null) {
                if (line.contains("[Effect@MaterialMap]")) {//reading materialmap section
                    oldtext += line + "\r\n";
                    line = br.readLine();
                    while (!line.contains("[Effect@")) {//till outlinemap

                        if (line.contains(pmdNum) && firstOne == true) {

                            firstOne = false;
                            String auxiliar = line;
                            auxiliar += "\r\n";//br
                            auxiliar += pmdNum + ".show = true" + "\r\n";//show+br
                            line = auxiliar + fors;
                            oldtext += line;
                            line = br.readLine();

                        } else if (line.contains(pmdNum) && firstOne != true) {
                            line = br.readLine();
                        } else {
                            oldtext += line + "\r\n";
                            line = br.readLine();
                        }
                    }
                }
                oldtext += line + "\r\n";
                line = br.readLine();
            }
            br.close();
            FileWriter fw = new FileWriter(MikuMikuDanceProjectPath);
            fw.write(oldtext);
            fw.close();
        } catch (Exception e) {

        }
    }

    public static void createMaterial(String Tex[], String destination, int num) throws IOException {

        File f = new File(destination + "/sub_" + num + ".fx");
        copyFile(v2.getFileToEdit(), f);

        try {
            BufferedReader br;
            br = new BufferedReader(new FileReader(f));
            String oldtext = "";
            String line = br.readLine();
            String catchOld = "";
            //todo add if statement for normal, specular, smoothness, metalness, parallax map, occlusion.
            while (line != null) {
                /*0 - Normal*/
                if (line.contains("#define NORMAL_MAP_FROM") && normalCheck) {
                    catchOld = line; //auxiliar line
                    catchOld = catchOld.replaceAll("\\D+", ""); //extract old digit
                    line = line.replaceAll(catchOld, "1"); //replace old for the new one

                }
                if (line.contains("#define NORMAL_MAP_FILE") && normalCheck) {
                    line = "#define NORMAL_MAP_FILE " + '"' + Tex[0] + '"';

                }
                /*1 - Specular*/
                if (line.contains("#define SPECULAR_MAP_FROM") && specularCheck) {
                    catchOld = line; //auxiliar line
                    catchOld = catchOld.replaceAll("\\D+", ""); //extract old digit
                    line = line.replaceAll(catchOld, "1"); //replace old for the new one

                }
                if (line.contains("#define SPECULAR_MAP_FILE") && specularCheck) {
                    line = "#define SPECULAR_MAP_FILE " + '"' + Tex[1] + '"';
                }
                /*2 - Smoothness*/
                if (line.contains("#define SMOOTHNESS_MAP_FROM") && smoothnessCheck) {
                    catchOld = line; //auxiliar line
                    catchOld = catchOld.replaceAll("\\D+", ""); //extract old digit
                    line = line.replaceAll(catchOld, "1"); //replace old for the new one

                }
                if (line.contains("#define SMOOTHNESS_MAP_FILE") && smoothnessCheck) {
                    line = "#define SMOOTHNESS_MAP_FILE " + '"' + Tex[2] + '"';
                }
                /*3 - metalness*/
                if (line.contains("#define METALNESS_MAP_FROM") && metalnessCheck) {
                    catchOld = line; //auxiliar line
                    catchOld = catchOld.replaceAll("\\D+", ""); //extract old digit
                    line = line.replaceAll(catchOld, "1"); //replace old for the new one

                }
                if (line.contains("#define METALNESS_MAP_FILE") && metalnessCheck) {
                    line = "#define METALNESS_MAP_FILE " + '"' + Tex[3] + '"';
                }
                /*4 - parallax*/
                if (line.contains("#define PARALLAX_MAP_FROM") && parallaxCheck) {
                    catchOld = line; //auxiliar line
                    catchOld = catchOld.replaceAll("\\D+", ""); //extract old digit
                    line = line.replaceAll(catchOld, "1"); //replace old for the new one

                }
                if (line.contains("#define PARALLAX_MAP_FILE") && parallaxCheck) {
                    line = "#define PARALLAX_MAP_FILE " + '"' + Tex[4] + '"';
                }
                /*5 - occlusion*/
                if (line.contains("#define OCCLUSION_MAP_FROM") && occlusionCheck) {
                    catchOld = line; //auxiliar line
                    catchOld = catchOld.replaceAll("\\D+", ""); //extract old digit
                    line = line.replaceAll(catchOld, "1"); //replace old for the new one

                }
                if (line.contains("#define OCCLUSION_MAP_FILE") && occlusionCheck) {
                    line = "#define OCCLUSION_MAP_FILE " + '"' + Tex[5] + '"';
                }
                oldtext += line + "\r\n";
                line = br.readLine();
            }
            String newtext = oldtext;
            br.close();
            FileWriter writer = new FileWriter(f);
            writer.write(newtext);
            writer.close();

        } catch (Exception e) {
        }

    }

    private static void copyFile(File source, File dest) throws IOException {
        InputStream is = null;
        OutputStream os = null;
        try {
            is = new FileInputStream(source);
            os = new FileOutputStream(dest);
            byte[] buffer = new byte[1024];
            int length;
            while ((length = is.read(buffer)) > 0) {
                os.write(buffer, 0, length);
            }
        } finally {
            is.close();
            os.close();
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private static javax.swing.JRadioButton MetalnessMap;
    private static javax.swing.JRadioButton NormalMap;
    private static javax.swing.JRadioButton OcclusionMap;
    private static javax.swing.JRadioButton ParallaxMap;
    private static javax.swing.JRadioButton SmoothnessMap;
    private static javax.swing.JRadioButton SpecularMap;
    private javax.swing.JButton Submit;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.ButtonGroup buttonGroup2;
    private javax.swing.ButtonGroup buttonGroup3;
    private javax.swing.JLabel jLabel1;
    // End of variables declaration//GEN-END:variables

    public String getSuffix(String type) {
        String suffix = "";
        try {

            do {
                suffix = (String) JOptionPane.showInputDialog(parentComponent/*a*/, "<html>If all your " + type + " Map Files have a suffix, please, specify it.<br><br>Example:<br>"
                        + "<ul>"
                        + "<li>roof<b>_normal</b>.png</li></ul>"
                        + "<br><br> LEAVE THIS BLANK IF NOT</html>", type + " Maps Suffix", EXIT_ON_CLOSE, img/*img*/, null, null);

            } while (suffix.contains("../") || suffix.contains("./") || suffix.contains("//") || (suffix.contains(".fx") || (suffix.equalsIgnoreCase("fx"))));
            

        } catch (Exception e) {
            File file_to_delete = v2.getFileToEdit();
            file_to_delete.delete();
        }
        return suffix;
    }

    private File getRealFiles(String line, String mapsPath, String[] suffixes, int type) {
        String aux = "";
        String catchOld = line;
        for (int i = catchOld.indexOf('"') + 1; i < line.length() - 2; i++) {
            if (catchOld.charAt(i) == '.') {
                aux += suffixes[type];//adding suffix
            }
            aux += catchOld.charAt(i); //GETTING TEXTUREMAP NAME FROM FILE
            //IN ORDER TO COMPARE TO THE ACTUAL MAP FILE
            //FROM MAPS FILE.
        }
        String fileName = new File(aux).getName();//gets the file name

        fileName = fileName.substring(0, fileName.lastIndexOf("."));//Deletes extension from the filename.

        File RealFile = compareFile(fileName, mapsPath); //returns name of the real map file, not the one from the .x file
        return RealFile;
    }
}
